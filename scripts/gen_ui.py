#!/usr/bin/env python3
import json
import os
import pathlib
import sys
from typing import Any, Dict


# Resolve repository root similarly to other generators
try:
    THIS = pathlib.Path(__file__).resolve()
    ROOT = THIS.parents[1]
except Exception:
    ROOT = pathlib.Path(os.getcwd())
    if (ROOT / "platformio.ini").exists():
        ROOT = ROOT.parent.parent

UI_SPEC_PATH = ROOT / "config" / "ui_spec.json"
FW_OUT_DIR = ROOT / "firmware" / "arduino" / "src"
FW_OUT_H = FW_OUT_DIR / "ui_generated.h"
FW_OUT_CPP = FW_OUT_DIR / "ui_generated.cpp"
WEB_SIM_DIR = ROOT / "web" / "sim"
WEB_OUT_JS = WEB_SIM_DIR / "ui_generated.js"


def _fail(msg: str) -> None:
    print(f"ERR: {msg}")
    sys.exit(1)


def load_ui_spec() -> Dict[str, Any]:
    if not UI_SPEC_PATH.exists():
        _fail(f"ui spec not found: {UI_SPEC_PATH}")
    try:
        data = json.loads(UI_SPEC_PATH.read_text())
    except Exception as e:
        _fail(f"failed to parse {UI_SPEC_PATH}: {e}")
    # Minimal validation
    if data.get("schema") != "ui-spec@1":
        _fail("ui_spec.json must contain \"schema\": \"ui-spec@1\"")
    if not isinstance(data.get("canvas"), dict):
        _fail("ui_spec.json missing canvas object")
    if not isinstance(data.get("rects"), dict) or not data["rects"]:
        _fail("ui_spec.json missing rects map")
    if not isinstance(data.get("components"), dict) or not data["components"]:
        _fail("ui_spec.json missing components map")
    if not isinstance(data.get("variants"), dict) or not data["variants"]:
        _fail("ui_spec.json missing variants map")
    return data


def emit_fw_header(spec: Dict[str, Any]) -> str:
    canvas = spec.get("canvas", {})
    w = int(canvas.get("w", 250))
    h = int(canvas.get("h", 122))
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Basic UI spec info")
    lines.append("namespace ui {")
    lines.append("struct SpecInfo { int canvas_w; int canvas_h; };")
    lines.append(f"static constexpr SpecInfo SPEC{{ {w}, {h} }};")
    # Export known variant names as ids for firmware-side selection
    lines.append("enum VariantId {")
    # Provide a stable ordering: minimal=0 if present, then others
    variant_names = list(spec.get("variants", {}).keys())
    # ensure deterministic order
    variant_names.sort()
    for idx, name in enumerate(variant_names):
        enum_name = f"UIVAR_{name.upper()}"
        lines.append(f"    {enum_name} = {idx},")
    lines.append("};")
    lines.append("}")
    lines.append("")
    return "\n".join(lines) + "\n"


def emit_fw_cpp(spec: Dict[str, Any]) -> str:
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#include \"ui_generated.h\"")
    lines.append("")
    # Intentionally minimal for now; firmware integration will consume geometry header
    lines.append("// Placeholder implementation. Full draw ops will be generated in a later step.")
    return "\n".join(lines) + "\n"


def emit_web_js(spec: Dict[str, Any]) -> str:
    # Keep the spec JSON and basic helpers in a self-invoking closure
    js_obj = json.dumps(spec, separators=(",", ":"))
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append("(function(){")
    lines.append("  try {")
    lines.append("    window.UI_SPEC = " + js_obj + ";")
    lines.append("  } catch (e) { /* ignore if window not present */ }")
    lines.append("")
    lines.append("  // Minimal helper: map weather strings to icon names using iconMap rules")
    lines.append("  function uiMapWeather(iconMap, weather){")
    lines.append("    const s = String(weather||'').toLowerCase();")
    lines.append("    if (!iconMap || !Array.isArray(iconMap)) return null;")
    lines.append("    for (const rule of iconMap){")
    lines.append("      if (rule && Array.isArray(rule.match)){")
    lines.append("        for (const m of rule.match){ if (s.includes(String(m).toLowerCase())) return rule.icon; }")
    lines.append("      } else if (rule && rule.default) { return rule.icon; }")
    lines.append("    }")
    lines.append("    return null;")
    lines.append("  }")
    lines.append("  try { window.uiMapWeather = (w)=>uiMapWeather((window.UI_SPEC||{}).iconMap, w); } catch(e){}");
    lines.append(")();")
    return "\n".join(lines) + "\n"


def main() -> None:
    spec = load_ui_spec()
    # Firmware outputs
    FW_OUT_DIR.mkdir(parents=True, exist_ok=True)
    FW_OUT_H.write_text(emit_fw_header(spec))
    FW_OUT_CPP.write_text(emit_fw_cpp(spec))
    # Web output
    WEB_SIM_DIR.mkdir(parents=True, exist_ok=True)
    WEB_OUT_JS.write_text(emit_web_js(spec))
    print(f"Wrote {FW_OUT_H.relative_to(ROOT)} and {FW_OUT_CPP.relative_to(ROOT)}")
    print(f"Wrote {WEB_OUT_JS.relative_to(ROOT)}")


if __name__ == "__main__":
    main()


