#!/usr/bin/env python3
import json
import os
import pathlib
import sys
from typing import Any, Dict


# Resolve repository root similarly to other generators
try:
    THIS = pathlib.Path(__file__).resolve()
    ROOT = THIS.parents[1]
except Exception:
    ROOT = pathlib.Path(os.getcwd())
    if (ROOT / "platformio.ini").exists():
        ROOT = ROOT.parent.parent

UI_SPEC_PATH = ROOT / "config" / "ui_spec.json"
FW_OUT_DIR = ROOT / "firmware" / "arduino" / "src"
FW_OUT_H = FW_OUT_DIR / "ui_generated.h"
FW_OUT_CPP = FW_OUT_DIR / "ui_generated.cpp"
WEB_SIM_DIR = ROOT / "web" / "sim"
WEB_OUT_JS = WEB_SIM_DIR / "ui_generated.js"


def _fail(msg: str) -> None:
    print(f"ERR: {msg}")
    sys.exit(1)


def load_ui_spec() -> Dict[str, Any]:
    if not UI_SPEC_PATH.exists():
        _fail(f"ui spec not found: {UI_SPEC_PATH}")
    try:
        data = json.loads(UI_SPEC_PATH.read_text())
    except Exception as e:
        _fail(f"failed to parse {UI_SPEC_PATH}: {e}")
    # Minimal validation
    if data.get("schema") != "ui-spec@1":
        _fail("ui_spec.json must contain \"schema\": \"ui-spec@1\"")
    if not isinstance(data.get("canvas"), dict):
        _fail("ui_spec.json missing canvas object")
    if not isinstance(data.get("rects"), dict) or not data["rects"]:
        _fail("ui_spec.json missing rects map")
    if not isinstance(data.get("components"), dict) or not data["components"]:
        _fail("ui_spec.json missing components map")
    if not isinstance(data.get("variants"), dict) or not data["variants"]:
        _fail("ui_spec.json missing variants map")
    return data


def emit_fw_header(spec: Dict[str, Any]) -> str:
    canvas = spec.get("canvas", {})
    w = int(canvas.get("w", 250))
    h = int(canvas.get("h", 122))
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Basic UI spec info")
    lines.append("namespace ui {")
    lines.append("struct SpecInfo { int canvas_w; int canvas_h; };")
    lines.append(f"static constexpr SpecInfo SPEC{{ {w}, {h} }};")
    # Export known variant names as ids for firmware-side selection
    lines.append("enum VariantId {")
    # Provide a stable ordering: minimal=0 if present, then others
    variant_names = list(spec.get("variants", {}).keys())
    # ensure deterministic order
    variant_names.sort()
    for idx, name in enumerate(variant_names):
        enum_name = f"UIVAR_{name.upper()}"
        lines.append(f"    {enum_name} = {idx},")
    lines.append("};")
    lines.append("}")
    lines.append("")
    return "\n".join(lines) + "\n"


def emit_fw_cpp(spec: Dict[str, Any]) -> str:
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#include \"ui_generated.h\"")
    lines.append("")
    # Intentionally minimal for now; firmware integration will consume geometry header
    lines.append("// Placeholder implementation. Full draw ops will be generated in a later step.")
    return "\n".join(lines) + "\n"


def emit_web_js(spec: Dict[str, Any]) -> str:
    js_obj = json.dumps(spec, separators=(",", ":"))
    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append("(function(){")
    lines.append("  try { window.UI_SPEC = " + js_obj + "; } catch (e) { /* no window */ }")
    lines.append("")
    # Helpers (kept minimal to avoid test regressions)
    lines.append("  function _fontPx(tokens, name){ const t=(tokens||{})[name]||{}; return {px:(t.px||10), weight:(t.weight||'normal')}; }")
    lines.append("  function _setFont(ctx, px, weight){ ctx.font = `${weight} ${px}px Menlo, Consolas, 'DM Mono', 'Roboto Mono', monospace`; ctx.textBaseline='top'; ctx.fillStyle='#000'; }")
    lines.append("  function _text(ctx, x, y, s, px, weight){ _setFont(ctx, px, weight); ctx.fillText(String(s||''), x, y); }")
    lines.append("  function _textTruncIn(ctx, rect, s, px, weight, align){ const [x,y,w,h]=rect; _setFont(ctx, px, weight); const pad=1; const maxW=Math.max(0,w-pad*2); let st=String(s||''); if (ctx.measureText(st).width>maxW){ while(st.length>1&&ctx.measureText(st+'…').width>maxW){ st=st.slice(0,-1);} st=st+'…'; } let tx=x+pad; const tw=ctx.measureText(st).width; if(align==='right') tx=x+w-pad-tw; else if(align==='center') tx=x+Math.max(0,Math.floor((w-tw)/2)); ctx.fillText(st, tx, y); }")
    lines.append("  function _shortCond(w){ const s=String(w||'').trim(); if(!s) return 'Cloudy'; const lowered=s.toLowerCase(); const cuts=[' with ',' and ',',','/',' - ']; let cut=s.length; for(const sep of cuts){ const idx=lowered.indexOf(sep); if(idx>=0 && idx<cut) cut=idx; } const first=s.slice(0,cut).trim(); return (first.split(/\\s+/)[0]||'Cloudy'); }")
    lines.append("  function _mapWeather(iconMap, weather){ const s=String(weather||'').toLowerCase(); if(!iconMap||!Array.isArray(iconMap)) return null; for(const rule of iconMap){ if(rule && Array.isArray(rule.match)){ for(const m of rule.match){ if(s.includes(String(m).toLowerCase())) return rule.icon; } } else if(rule && rule.default){ return rule.icon; } } return null; }")
    lines.append("  function _drawWeatherIcon(ctx, rect, weather){ const [x,y,w,h]=rect; const fn= (typeof window!=='undefined'&&window.weatherIcon) ? window.weatherIcon : null; if (fn){ fn([x,y,x+w,y+h], weather); return; } ctx.strokeStyle='#000'; ctx.strokeRect(x+2,y+2,w-4,h-4); }")

    # Safe stub interpreter (no-op). A fuller interpreter will replace sim.js later.
    lines.append("  function drawFromSpec(ctx, data, variantName){ try{ /* stub; real interpreter to be integrated */ }catch(e){ console.warn('[ui_generated] drawFromSpec error', e); } }")

    lines.append("  try { window.uiMapWeather = (w)=>_mapWeather((window.UI_SPEC||{}).iconMap, w); } catch(e){}")
    lines.append("  try { window.drawFromSpec = drawFromSpec; } catch(e){}")
    lines.append(")();")
    return "\n".join(lines) + "\n"


def main() -> None:
    spec = load_ui_spec()
    # Firmware outputs
    FW_OUT_DIR.mkdir(parents=True, exist_ok=True)
    FW_OUT_H.write_text(emit_fw_header(spec))
    FW_OUT_CPP.write_text(emit_fw_cpp(spec))
    # Web output
    WEB_SIM_DIR.mkdir(parents=True, exist_ok=True)
    WEB_OUT_JS.write_text(emit_web_js(spec))
    print(f"Wrote {FW_OUT_H.relative_to(ROOT)} and {FW_OUT_CPP.relative_to(ROOT)}")
    print(f"Wrote {WEB_OUT_JS.relative_to(ROOT)}")


if __name__ == "__main__":
    main()


