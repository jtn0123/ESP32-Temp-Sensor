#!/usr/bin/env python3
import json
import os
import pathlib
import sys
from typing import Any, Dict
import subprocess
import zlib

try:
    import yaml  # type: ignore
except Exception:
    yaml = None


# Resolve repository root similarly to other generators
try:
    THIS = pathlib.Path(__file__).resolve()
    ROOT = THIS.parents[1]
except Exception:
    ROOT = pathlib.Path(os.getcwd())
    if (ROOT / "platformio.ini").exists():
        ROOT = ROOT.parent.parent

UI_SPEC_PATH = ROOT / "config" / "ui_spec.json"
FW_OUT_DIR = ROOT / "firmware" / "arduino" / "src"
FW_OUT_H = FW_OUT_DIR / "ui_generated.h"
FW_OUT_CPP = FW_OUT_DIR / "ui_generated.cpp"
WEB_SIM_DIR = ROOT / "web" / "sim"
WEB_OUT_JS = WEB_SIM_DIR / "ui_generated.js"
FW_LAYOUT_H = FW_OUT_DIR / "display_layout.h"
LEGACY_GEOM_JSON = ROOT / "config" / "display_geometry.json"
FW_OPS_H = FW_OUT_DIR / "ui_ops_generated.h"
FW_OPS_CPP = FW_OUT_DIR / "ui_ops_generated.cpp"


def _fail(msg: str) -> None:
    print(f"ERR: {msg}")
    sys.exit(1)


def load_ui_spec() -> Dict[str, Any]:
    if not UI_SPEC_PATH.exists():
        _fail(f"ui spec not found: {UI_SPEC_PATH}")
    try:
        data = json.loads(UI_SPEC_PATH.read_text())
    except Exception as e:
        _fail(f"failed to parse {UI_SPEC_PATH}: {e}")
    # Minimal validation
    if data.get("schema") != "ui-spec@1":
        _fail("ui_spec.json must contain \"schema\": \"ui-spec@1\"")
    if not isinstance(data.get("canvas"), dict):
        _fail("ui_spec.json missing canvas object")
    if not isinstance(data.get("rects"), dict) or not data["rects"]:
        _fail("ui_spec.json missing rects map")
    if not isinstance(data.get("components"), dict) or not data["components"]:
        _fail("ui_spec.json missing components map")
    if not isinstance(data.get("variants"), dict) or not data["variants"]:
        _fail("ui_spec.json missing variants map")
    return data


def emit_fw_header(spec: Dict[str, Any]) -> str:
    canvas = spec.get("canvas", {})
    w = int(canvas.get("w", 250))
    h = int(canvas.get("h", 122))
    # Build explicit variant ordering: MINIMAL=0 if present, then V1, V2 if present
    variants = spec.get("variants", {})
    order: list[str] = []
    if "minimal" in variants:
        order.append("minimal")
    for name in ["v1", "v2"]:
        if name in variants:
            order.append(name)
    # Fallback: append any others not already listed in sorted order
    for name in sorted(variants.keys()):
        if name not in order:
            order.append(name)
    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Basic UI spec info")
    lines.append("namespace ui {")
    lines.append("struct SpecInfo { int canvas_w; int canvas_h; };")
    lines.append(f"static constexpr SpecInfo SPEC{{ {w}, {h} }};")
    lines.append("enum VariantId {")
    for idx, name in enumerate(order):
        lines.append(f"    UIVAR_{name.upper()} = {idx},")
    lines.append("};")
    lines.append("}")
    lines.append("")
    return "\n".join(lines) + "\n"


def emit_fw_cpp(spec: Dict[str, Any]) -> str:
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#include \"ui_generated.h\"")
    lines.append("")
    lines.append("// Placeholder implementation. Full draw ops will be generated in a later step.")
    return "\n".join(lines) + "\n"


def emit_fw_layout_header(spec: Dict[str, Any]) -> str:
    import hashlib
    canvas = spec.get("canvas", {})
    rects = spec.get("rects", {})
    w = int(canvas.get("w", 250))
    h = int(canvas.get("h", 122))
    digest = hashlib.md5(json.dumps({"canvas": canvas, "rects": rects}, sort_keys=True).encode("utf-8")).hexdigest()
    # Compute CRC32 over canonical canvas+rects for parity check
    crc = zlib.crc32(json.dumps({"canvas": canvas, "rects": rects}, sort_keys=True).encode("utf-8")) & 0xFFFFFFFF
    layout_version = int(spec.get("layoutVersion", spec.get("version", 1)))

    def emitted_name(name: str) -> str:
        return "STATUS_" if name == "STATUS" else name

    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append(f"// md5: {digest}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Layout identity for simulator ↔ firmware parity checks")
    lines.append(f"#define LAYOUT_VERSION {layout_version}")
    lines.append(f"#define LAYOUT_CRC 0x{crc:08X}u")
    lines.append(f"#define LAYOUT_MD5 \"{digest}\"")
    lines.append("")
    lines.append("// Display dimensions")
    lines.append("#ifndef EINK_WIDTH")
    lines.append(f"#define EINK_WIDTH {w}")
    lines.append("#endif")
    lines.append("#ifndef EINK_HEIGHT")
    lines.append(f"#define EINK_HEIGHT {h}")
    lines.append("#endif")
    lines.append("")
    lines.append("// Partial update windows (x, y, w, h) — generated from ui_spec.json")
    for name, xywh in rects.items():
        x, y, rw, rh = [int(v) for v in xywh]
        var = emitted_name(name)
        lines.append(f"static constexpr int {var}[4] = {{ {x:3d}, {y:3d}, {rw:3d}, {rh:2d}}};")
    lines.append("")
    lines.append("enum WeatherIconId {")
    lines.append("    ICON_CLEAR = 0,")
    lines.append("    ICON_PARTLY,")
    lines.append("    ICON_CLOUDY,")
    lines.append("    ICON_RAIN,")
    lines.append("    ICON_STORM,")
    lines.append("    ICON_SNOW,")
    lines.append("    ICON_FOG,")
    lines.append("};")
    lines.append("")
    lines.append("// Compile-time layout sanity checks (widths/heights within bounds)")
    for name, xywh in rects.items():
        x, y, rw, rh = [int(v) for v in xywh]
        var = emitted_name(name)
        lines.append(f'static_assert({var}[0] >= 0 && {var}[1] >= 0, "{name} origin");')
        lines.append(f'static_assert({x} + {rw} <= EINK_WIDTH,  "{name} width");')
        lines.append(f'static_assert({y} + {rh} <= EINK_HEIGHT, "{name} height");')
    if "STATUS" in rects:
        lines.append('static_assert(STATUS_[0] + STATUS_[2] <= EINK_WIDTH,  "STATUS_ width");')
    lines.append("")
    return "\n".join(lines) + "\n"


def emit_web_js(spec: Dict[str, Any]) -> str:
	js_obj = json.dumps(spec, separators=(",", ":"))
	# Compute layout identity for the browser too
	canvas = spec.get("canvas", {})
	rects = spec.get("rects", {})
	layout_version = int(spec.get("layoutVersion", spec.get("version", 1)))
	crc = zlib.crc32(json.dumps({"canvas": canvas, "rects": rects}, sort_keys=True).encode("utf-8")) & 0xFFFFFFFF
	fw_version = str(os.environ.get("FW_VERSION", "") or "")
	if not fw_version:
		cfg_yaml = ROOT / "config" / "device.yaml"
		if not cfg_yaml.exists():
			cfg_yaml = ROOT / "config" / "device.sample.yaml"
		try:
			if yaml is not None and cfg_yaml.exists():
				with open(cfg_yaml, "r") as f:
					y = yaml.safe_load(f) or {}
				v = str(y.get("fw_version", "") or "")
				if v:
					fw_version = v
		except Exception:
			pass
	if not fw_version:
		try:
			fw_version = (
				subprocess.check_output(["git", "describe", "--tags", "--always", "--dirty"], cwd=str(ROOT), stderr=subprocess.DEVNULL)
				.decode("utf-8", "ignore").strip()
			)
		except Exception:
			try:
				fw_version = (
					subprocess.check_output(["git", "rev-parse", "--short", "HEAD"], cwd=str(ROOT), stderr=subprocess.DEVNULL)
					.decode("utf-8", "ignore").strip()
				)
			except Exception:
				fw_version = "dev"
	lines: list[str] = []
	lines.append("// AUTO-GENERATED by scripts/gen_ui.py - DO NOT EDIT")
	lines.append("window.UI_SPEC = " + js_obj + ";")
	lines.append("window.UI_FW_VERSION = " + json.dumps(fw_version) + ";")
	lines.append("window.UI_LAYOUT_VERSION = " + json.dumps(layout_version) + ";")
	lines.append("window.UI_LAYOUT_CRC = \"0x%08X\";" % crc)
	lines.append("(function(){ function _mapWeather(iconMap, weather){ var s=String(weather||'').toLowerCase(); if(!iconMap||!Array.isArray(iconMap)) return null; for(var i=0;i<iconMap.length;i++){ var rule=iconMap[i]; if(rule && Array.isArray(rule.match)){ for(var j=0;j<rule.match.length;j++){ var m=rule.match[j]; if(s.indexOf(String(m).toLowerCase())>=0) return rule.icon; } } else if(rule && rule.default){ return rule.icon; } } return null; } window.uiMapWeather = function(w){ var spec = window.UI_SPEC || {}; return _mapWeather(spec.iconMap, w); }; })();")
	return "\n".join(lines) + "\n"


def emit_legacy_geometry_json(spec: Dict[str, Any]) -> str:
    # Keep legacy geometry JSON in sync for tests and fallback paths
    canvas = spec.get("canvas", {})
    tokens = ((spec.get("fonts") or {}).get("tokens") or {})
    rects = spec.get("rects", {})
    layout_version = int(spec.get("layoutVersion", spec.get("version", 1)))
    crc = zlib.crc32(json.dumps({"canvas": canvas, "rects": rects}, sort_keys=True).encode("utf-8")) & 0xFFFFFFFF
    obj = {
        "layout_version": layout_version,
        "layout_crc": f"0x{crc:08X}",
        "canvas": {"w": int(canvas.get("w", 250)), "h": int(canvas.get("h", 122))},
        "fonts": {
            "big_px": int((tokens.get("big") or {}).get("px", 22)),
            "mid_px": int((tokens.get("label") or {}).get("px", 11)),
            "small_px": int((tokens.get("small") or {}).get("px", 10)),
        },
        "rects": rects,
    }
    return json.dumps(obj, indent=2)


def emit_fw_ops_header(spec: Dict[str, Any]) -> str:
    variants = spec.get("variants", {})
    components = spec.get("components", {})
    rects = spec.get("rects", {})
    fonts_tokens = ((spec.get("fonts") or {}).get("tokens") or {})
    # Stable variant order
    order: list[str] = []
    if "minimal" in variants:
        order.append("minimal")
    for name in ["v1", "v2"]:
        if name in variants and name not in order:
            order.append(name)
    for name in sorted(variants.keys()):
        if name not in order:
            order.append(name)
    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("")
    lines.append("namespace ui {")
    # RectId enum from rects keys, stable ordering by key
    rect_names = sorted(rects.keys())
    lines.append("enum RectId {")
    for name in rect_names:
        lines.append(f"    RECT_{name.upper()},")
    lines.append("    RECT__COUNT,")
    lines.append("};")
    lines.append("")
    # FontId enum from tokens
    font_order = []
    for n in ["big", "label", "small", "time"]:
        if n in fonts_tokens and n not in font_order:
            font_order.append(n)
    for n in sorted(fonts_tokens.keys()):
        if n not in font_order:
            font_order.append(n)
    lines.append("enum FontId {")
    for name in font_order:
        lines.append(f"    FONT_{name.upper()},")
    lines.append("    FONT__COUNT,")
    lines.append("};")
    lines.append("")
    # Alignment flags
    lines.append("enum Align { ALIGN_LEFT=0, ALIGN_RIGHT=1, ALIGN_CENTER=2 };")
    lines.append("")
    # Ops enum derived from spec ops
    op_kinds: set[str] = set()
    for ops in components.values():
        for op in ops:
            k = str(op.get("op", "")).strip()
            if k:
                op_kinds.add(k)
    kinds_sorted = sorted(op_kinds)
    lines.append("enum UiOpKind {")
    for k in kinds_sorted:
        enum_name = "OP_" + k.upper()
        lines.append(f"    {enum_name},")
    lines.append("};")
    lines.append("")
    # Simple op header (future: multiple op payload shapes)
    lines.append("struct UiOpHeader { uint8_t kind; uint8_t rect; uint8_t font; uint8_t align; int16_t p0; int16_t p1; int16_t p2; int16_t p3; const char* s0; const char* s1; };")
    lines.append("")
    # Variant names
    lines.append("static constexpr const char* kVariantNames[] = {")
    for name in order:
        lines.append(f"    \"{name}\",")
    lines.append("};")
    lines.append("")
    # Component name lists per variant (by string for now)
    for name in order:
        comp_list = variants.get(name, [])
        arr_name = f"kVariant_{name}_components"
        lines.append(f"static constexpr const char* {arr_name}[] = {{")
        for c in comp_list:
            lines.append(f"    \"{c}\",")
        lines.append("};")
    lines.append("")
    # Component op counts (as a quick reference)
    for cname, ops in components.items():
        lines.append(f"static constexpr int kComponent_{cname}_opcount = {len(ops)};")
    # Total counts
    total_ops = sum(len(v) for v in components.values())
    lines.append(f"static constexpr int kTotalOpCount = {total_ops};")
    lines.append("")
    # ComponentOps mapping per variant
    lines.append("struct ComponentOps { const UiOpHeader* ops; int count; const char* name; };")
    for vname in order:
        lines.append(f"extern const ComponentOps kVariant_{vname}_ops[];")
        lines.append(f"extern const int kVariant_{vname}_ops_count;")
    lines.append("extern const ComponentOps* get_variant_ops(uint8_t variantId, int* outCount);")
    lines.append("")
    lines.append("} // namespace ui")
    return "\n".join(lines) + "\n"


def _cxx_string_literal(s: str) -> str:
    return '"' + s.replace('\\', r'\\').replace('"', r'\"') + '"'


def emit_fw_ops_cpp(spec: Dict[str, Any]) -> str:
    variants = spec.get("variants", {})
    components = spec.get("components", {})
    rects = spec.get("rects", {})
    fonts_tokens = ((spec.get("fonts") or {}).get("tokens") or {})

    # Rect ids map
    rect_names = sorted(rects.keys())
    rect_to_id = {name: idx for idx, name in enumerate(rect_names)}
    # Font ids map
    font_order: list[str] = []
    for n in ["big", "label", "small", "time"]:
        if n in fonts_tokens and n not in font_order:
            font_order.append(n)
    for n in sorted(fonts_tokens.keys()):
        if n not in font_order:
            font_order.append(n)
    font_to_id = {name: idx for idx, name in enumerate(font_order)}

    def align_code(a: str | None) -> int:
        if not a:
            return 0
        a2 = str(a).lower()
        if a2 == "right":
            return 1
        if a2 == "center":
            return 2
        return 0

    def rect_id(name: str | None) -> int:
        if not name:
            return 255
        return int(rect_to_id.get(name, 255))

    def font_id(name: str | None) -> int:
        if not name:
            return 0
        return int(font_to_id.get(name, 0))

    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#include <cstddef>")
    lines.append("#include \"ui_ops_generated.h\"")
    lines.append("")
    lines.append("namespace ui {")
    lines.append("")
    # Emit ops per component
    for cname, ops in components.items():
        arr_name = f"kOps_{cname}"
        lines.append(f"const UiOpHeader {arr_name}[] = {{")
        for op in ops:
            kind = str(op.get("op", "")).strip()
            kind_enum = "OP_" + kind.upper()
            rname = op.get("rect")
            rid = rect_id(rname) if isinstance(rname, str) else 255
            f = font_id(str(op.get("font")))
            align = align_code(str(op.get("align")))
            p0 = p1 = p2 = p3 = 0
            s0 = s1 = "NULL"
            if kind == "line":
                frm = op.get("from") or [0, 0]
                to = op.get("to") or [0, 0]
                p0, p1 = int(frm[0]), int(frm[1])
                p2, p3 = int(to[0]), int(to[1])
            elif kind == "text":
                # Pass template through; device interprets placeholders like {ip}, {fw_version}
                txt = str(op.get("text", ""))
                s0 = _cxx_string_literal(txt)
                try:
                    p0 = int(op.get("x", 0))
                    p1 = int(op.get("y", 0))
                except Exception:
                    p0 = p1 = 0
            elif kind == "timeRight":
                src = str(op.get("source", "")).strip().strip("{}")
                s0 = _cxx_string_literal(src)
                align = 1
            elif kind == "labelCentered":
                # Use aboveRect as rect; stash y in p0 and text in s0
                rid = rect_id(str(op.get("aboveRect")))
                try:
                    p0 = int(op.get("y", 0))
                except Exception:
                    p0 = 0
                s0 = _cxx_string_literal(str(op.get("text", "")))
                align = 2
            elif kind == "tempGroupCentered":
                val = str(op.get("value", "")).strip().strip("{}")
                s0 = _cxx_string_literal(val)
                align = 2
            elif kind == "textCenteredIn":
                try:
                    p0 = int(op.get("yOffset", 0))
                except Exception:
                    p0 = 0
                s0 = _cxx_string_literal(str(op.get("text", "")))
                align = 2
            elif kind == "iconIn":
                src = str(op.get("iconFromWeather", "")).strip().strip("{}")
                s0 = _cxx_string_literal(src)
            elif kind == "shortCondition":
                try:
                    p0 = int(op.get("xOffset", 0))
                except Exception:
                    p0 = 0
            elif kind == "batteryGlyph":
                try:
                    p0 = int(op.get("x", 0)); p1 = int(op.get("y", 0)); p2 = int(op.get("w", 0)); p3 = int(op.get("h", 0))
                except Exception:
                    p0 = p1 = p2 = p3 = 0
                src = str(op.get("percent", "")).strip().strip("{}")
                s0 = _cxx_string_literal(src)
            # Emit row
            lines.append(f"    {{ {kind_enum}, {rid}, {f}, {align}, {p0}, {p1}, {p2}, {p3}, {s0}, {s1} }},")
        lines.append("};")
        lines.append(f"const int kOps_{cname}_count = sizeof({arr_name})/sizeof({arr_name}[0]);")
        lines.append("")
    # Emit variant to component mapping arrays
    def ops_arr_name(cn: str) -> str:
        return f"kOps_{cn}"
    for vname, comp_list in variants.items():
        lines.append(f"const ComponentOps kVariant_{vname}_ops[] = {{")
        for cn in comp_list:
            lines.append(f"    {{ {ops_arr_name(cn)}, kOps_{cn}_count, \"{cn}\" }},")
        lines.append("};")
        lines.append(f"const int kVariant_{vname}_ops_count = sizeof(kVariant_{vname}_ops)/sizeof(kVariant_{vname}_ops[0]);")
        lines.append("")
    # Provide a simple id->array lookup using the same id order as header (minimal,v1,v2, then others)
    # Build the same order
    order: list[str] = []
    if "minimal" in variants: order.append("minimal")
    for n in ["v1", "v2"]:
        if n in variants and n not in order: order.append(n)
    for n in sorted(variants.keys()):
        if n not in order: order.append(n)
    lines.append("const ComponentOps* get_variant_ops(uint8_t variantId, int* outCount){")
    for idx, vn in enumerate(order):
        prefix = "  if" if idx == 0 else "  else if"
        lines.append(f"{prefix} (variantId == {idx}) {{ if(outCount) *outCount = kVariant_{vn}_ops_count; return kVariant_{vn}_ops; }}")
    lines.append("  if(outCount) *outCount = 0; return nullptr;")
    lines.append("}")
    lines.append("")
    lines.append("} // namespace ui")
    return "\n".join(lines) + "\n"


def main() -> None:
    spec = load_ui_spec()
    # Firmware outputs
    FW_OUT_DIR.mkdir(parents=True, exist_ok=True)
    FW_OUT_H.write_text(emit_fw_header(spec))
    FW_OUT_CPP.write_text(emit_fw_cpp(spec))
    # Also emit display_layout.h from the spec to keep geometry in sync
    FW_LAYOUT_H.write_text(emit_fw_layout_header(spec))
    # Emit ops header scaffold (not referenced yet)
    FW_OPS_H.write_text(emit_fw_ops_header(spec))
    FW_OPS_CPP.write_text(emit_fw_ops_cpp(spec))
    # Emit legacy geometry JSON to keep existing scripts/tests in sync
    LEGACY_GEOM_JSON.write_text(emit_legacy_geometry_json(spec))
    # Web output
    WEB_SIM_DIR.mkdir(parents=True, exist_ok=True)
    WEB_OUT_JS.write_text(emit_web_js(spec))
    print(f"Wrote {FW_OUT_H.relative_to(ROOT)} and {FW_OUT_CPP.relative_to(ROOT)}")
    print(f"Wrote {WEB_OUT_JS.relative_to(ROOT)}")
    print(f"Wrote {LEGACY_GEOM_JSON.relative_to(ROOT)}")


if __name__ == "__main__":
    main()


