#!/usr/bin/env python3
import json
import os
import pathlib
import sys
from typing import Any, Dict
import subprocess

try:
    import yaml  # type: ignore
except Exception:
    yaml = None


# Resolve repository root similarly to other generators
try:
    THIS = pathlib.Path(__file__).resolve()
    ROOT = THIS.parents[1]
except Exception:
    ROOT = pathlib.Path(os.getcwd())
    if (ROOT / "platformio.ini").exists():
        ROOT = ROOT.parent.parent

UI_SPEC_PATH = ROOT / "config" / "ui_spec.json"
FW_OUT_DIR = ROOT / "firmware" / "arduino" / "src"
FW_OUT_H = FW_OUT_DIR / "ui_generated.h"
FW_OUT_CPP = FW_OUT_DIR / "ui_generated.cpp"
WEB_SIM_DIR = ROOT / "web" / "sim"
WEB_OUT_JS = WEB_SIM_DIR / "ui_generated.js"
FW_LAYOUT_H = FW_OUT_DIR / "display_layout.h"
LEGACY_GEOM_JSON = ROOT / "config" / "display_geometry.json"


def _fail(msg: str) -> None:
    print(f"ERR: {msg}")
    sys.exit(1)


def load_ui_spec() -> Dict[str, Any]:
    if not UI_SPEC_PATH.exists():
        _fail(f"ui spec not found: {UI_SPEC_PATH}")
    try:
        data = json.loads(UI_SPEC_PATH.read_text())
    except Exception as e:
        _fail(f"failed to parse {UI_SPEC_PATH}: {e}")
    # Minimal validation
    if data.get("schema") != "ui-spec@1":
        _fail("ui_spec.json must contain \"schema\": \"ui-spec@1\"")
    if not isinstance(data.get("canvas"), dict):
        _fail("ui_spec.json missing canvas object")
    if not isinstance(data.get("rects"), dict) or not data["rects"]:
        _fail("ui_spec.json missing rects map")
    if not isinstance(data.get("components"), dict) or not data["components"]:
        _fail("ui_spec.json missing components map")
    if not isinstance(data.get("variants"), dict) or not data["variants"]:
        _fail("ui_spec.json missing variants map")
    return data


def emit_fw_header(spec: Dict[str, Any]) -> str:
    canvas = spec.get("canvas", {})
    w = int(canvas.get("w", 250))
    h = int(canvas.get("h", 122))
    # Build explicit variant ordering: MINIMAL=0 if present, then V1, V2 if present
    variants = spec.get("variants", {})
    order: list[str] = []
    if "minimal" in variants:
        order.append("minimal")
    for name in ["v1", "v2"]:
        if name in variants:
            order.append(name)
    # Fallback: append any others not already listed in sorted order
    for name in sorted(variants.keys()):
        if name not in order:
            order.append(name)
    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Basic UI spec info")
    lines.append("namespace ui {")
    lines.append("struct SpecInfo { int canvas_w; int canvas_h; };")
    lines.append(f"static constexpr SpecInfo SPEC{{ {w}, {h} }};")
    lines.append("enum VariantId {")
    for idx, name in enumerate(order):
        lines.append(f"    UIVAR_{name.upper()} = {idx},")
    lines.append("};")
    lines.append("}")
    lines.append("")
    return "\n".join(lines) + "\n"


def emit_fw_cpp(spec: Dict[str, Any]) -> str:
    lines = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append("#include \"ui_generated.h\"")
    lines.append("")
    lines.append("// Placeholder implementation. Full draw ops will be generated in a later step.")
    return "\n".join(lines) + "\n"


def emit_fw_layout_header(spec: Dict[str, Any]) -> str:
    import hashlib
    canvas = spec.get("canvas", {})
    rects = spec.get("rects", {})
    w = int(canvas.get("w", 250))
    h = int(canvas.get("h", 122))
    digest = hashlib.md5(json.dumps({"canvas": canvas, "rects": rects}, sort_keys=True).encode("utf-8")).hexdigest()

    def emitted_name(name: str) -> str:
        return "STATUS_" if name == "STATUS" else name

    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append(f"// source: {UI_SPEC_PATH.as_posix()}")
    lines.append(f"// md5: {digest}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Display dimensions")
    lines.append("#ifndef EINK_WIDTH")
    lines.append(f"#define EINK_WIDTH {w}")
    lines.append("#endif")
    lines.append("#ifndef EINK_HEIGHT")
    lines.append(f"#define EINK_HEIGHT {h}")
    lines.append("#endif")
    lines.append("")
    lines.append("// Partial update windows (x, y, w, h) — generated from ui_spec.json")
    for name, xywh in rects.items():
        x, y, rw, rh = [int(v) for v in xywh]
        var = emitted_name(name)
        lines.append(f"static constexpr int {var}[4] = {{ {x:3d}, {y:3d}, {rw:3d}, {rh:2d}}};")
    lines.append("")
    lines.append("enum WeatherIconId {")
    lines.append("    ICON_CLEAR = 0,")
    lines.append("    ICON_PARTLY,")
    lines.append("    ICON_CLOUDY,")
    lines.append("    ICON_RAIN,")
    lines.append("    ICON_STORM,")
    lines.append("    ICON_SNOW,")
    lines.append("    ICON_FOG,")
    lines.append("};")
    lines.append("")
    lines.append("// Compile-time layout sanity checks (widths/heights within bounds)")
    for name, xywh in rects.items():
        x, y, rw, rh = [int(v) for v in xywh]
        var = emitted_name(name)
        lines.append(f'static_assert({var}[0] >= 0 && {var}[1] >= 0, "{name} origin");')
        lines.append(f'static_assert({x} + {rw} <= EINK_WIDTH,  "{name} width");')
        lines.append(f'static_assert({y} + {rh} <= EINK_HEIGHT, "{name} height");')
    if "STATUS" in rects:
        lines.append('static_assert(STATUS_[0] + STATUS_[2] <= EINK_WIDTH,  "STATUS_ width");')
    lines.append("")
    return "\n".join(lines) + "\n"


def emit_web_js(spec: Dict[str, Any]) -> str:
    js_obj = json.dumps(spec, separators=(",", ":"))
    # Determine firmware version to keep sim in sync with device
    fw_version = str(os.environ.get("FW_VERSION", "") or "")
    if not fw_version:
        cfg_yaml = ROOT / "config" / "device.yaml"
        if not cfg_yaml.exists():
            cfg_yaml = ROOT / "config" / "device.sample.yaml"
        try:
            if yaml is not None and cfg_yaml.exists():
                with open(cfg_yaml, "r") as f:
                    y = yaml.safe_load(f) or {}
                v = str(y.get("fw_version", "") or "")
                if v:
                    fw_version = v
        except Exception:
            pass
    if not fw_version:
        try:
            fw_version = (
                subprocess.check_output(["git", "describe", "--tags", "--always", "--dirty"], cwd=str(ROOT), stderr=subprocess.DEVNULL)
                .decode("utf-8", "ignore").strip()
            )
        except Exception:
            try:
                fw_version = (
                    subprocess.check_output(["git", "rev-parse", "--short", "HEAD"], cwd=str(ROOT), stderr=subprocess.DEVNULL)
                    .decode("utf-8", "ignore").strip()
                )
            except Exception:
                fw_version = "dev"
    lines: list[str] = []
    lines.append("// AUTO-GENERATED by scripts/gen_ui.py — DO NOT EDIT")
    lines.append("(function(){")
    lines.append("  try { window.UI_SPEC = " + js_obj + "; } catch (e) { /* no window */ }")
    # Expose FW version for sim rendering to match device
    lines.append(f"  try {{ if (typeof window !== 'undefined') window.UI_FW_VERSION = {json.dumps(fw_version)}; }} catch(e){{}}");
    lines.append("")
    # Helpers (kept minimal to avoid test regressions)
    lines.append("  function _fontPx(tokens, name){ const t=(tokens||{})[name]||{}; return {px:(t.px||10), weight:(t.weight||'normal')}; }")
    lines.append("  function _setFont(ctx, px, weight){ ctx.font = `${weight} ${px}px Menlo, Consolas, 'DM Mono', 'Roboto Mono', monospace`; ctx.textBaseline='top'; ctx.fillStyle='#000'; }")
    lines.append("  function _text(ctx, x, y, s, px, weight){ _setFont(ctx, px, weight); ctx.fillText(String(s||''), x, y); }")
    lines.append("  function _textTruncIn(ctx, rect, s, px, weight, align){ const [x,y,w,h]=rect; _setFont(ctx, px, weight); const pad=1; const maxW=Math.max(0,w-pad*2); let st=String(s||''); if (ctx.measureText(st).width>maxW){ while(st.length>1&&ctx.measureText(st+'…').width>maxW){ st=st.slice(0,-1);} st=st+'…'; } let tx=x+pad; const tw=ctx.measureText(st).width; if(align==='right') tx=x+w-pad-tw; else if(align==='center') tx=x+Math.max(0,Math.floor((w-tw)/2)); ctx.fillText(st, tx, y); }")
    lines.append("  function _shortCond(w){ const s=String(w||'').trim(); if(!s) return 'Cloudy'; const lowered=s.toLowerCase(); const cuts=[' with ',' and ',',','/',' - ']; let cut=s.length; for(const sep of cuts){ const idx=lowered.indexOf(sep); if(idx>=0 && idx<cut) cut=idx; } const first=s.slice(0,cut).trim(); return (first.split(/\\s+/)[0]||'Cloudy'); }")
    lines.append("  function _mapWeather(iconMap, weather){ const s=String(weather||'').toLowerCase(); if(!iconMap||!Array.isArray(iconMap)) return null; for(const rule of iconMap){ if(rule && Array.isArray(rule.match)){ for(const m of rule.match){ if(s.includes(String(m).toLowerCase())) return rule.icon; } } else if(rule && rule.default){ return rule.icon; } } return null; }")
    lines.append("  function _drawWeatherIcon(ctx, rect, weather){ const [x,y,w,h]=rect; const fn= (typeof window!=='undefined'&&window.weatherIcon) ? window.weatherIcon : null; if (fn){ fn([x,y,x+w,y+h], weather); return; } ctx.strokeStyle='#000'; ctx.strokeRect(x+2,y+2,w-4,h-4); }")

    # Safe stub interpreter (no-op). A fuller interpreter will replace sim.js later.
    lines.append("  function drawFromSpec(ctx, data, variantName){ try{ /* stub; real interpreter to be integrated */ }catch(e){ console.warn('[ui_generated] drawFromSpec error', e); } }")

    lines.append("  try { window.uiMapWeather = (w)=>_mapWeather((window.UI_SPEC||{}).iconMap, w); } catch(e){}")
    lines.append("  try { window.drawFromSpec = drawFromSpec; } catch(e){}")
    lines.append(")();")
    return "\n".join(lines) + "\n"


def emit_legacy_geometry_json(spec: Dict[str, Any]) -> str:
    # Keep legacy geometry JSON in sync for tests and fallback paths
    canvas = spec.get("canvas", {})
    tokens = ((spec.get("fonts") or {}).get("tokens") or {})
    rects = spec.get("rects", {})
    obj = {
        "version": 1,
        "canvas": {"w": int(canvas.get("w", 250)), "h": int(canvas.get("h", 122))},
        "fonts": {
            "big_px": int((tokens.get("big") or {}).get("px", 22)),
            "mid_px": int((tokens.get("label") or {}).get("px", 11)),
            "small_px": int((tokens.get("small") or {}).get("px", 10)),
        },
        "rects": rects,
    }
    return json.dumps(obj, indent=2)


def main() -> None:
    spec = load_ui_spec()
    # Firmware outputs
    FW_OUT_DIR.mkdir(parents=True, exist_ok=True)
    FW_OUT_H.write_text(emit_fw_header(spec))
    FW_OUT_CPP.write_text(emit_fw_cpp(spec))
    # Also emit display_layout.h from the spec to keep geometry in sync
    FW_LAYOUT_H.write_text(emit_fw_layout_header(spec))
    # Emit legacy geometry JSON to keep existing scripts/tests in sync
    LEGACY_GEOM_JSON.write_text(emit_legacy_geometry_json(spec))
    # Web output
    WEB_SIM_DIR.mkdir(parents=True, exist_ok=True)
    WEB_OUT_JS.write_text(emit_web_js(spec))
    print(f"Wrote {FW_OUT_H.relative_to(ROOT)} and {FW_OUT_CPP.relative_to(ROOT)}")
    print(f"Wrote {WEB_OUT_JS.relative_to(ROOT)}")
    print(f"Wrote {LEGACY_GEOM_JSON.relative_to(ROOT)}")


if __name__ == "__main__":
    main()


